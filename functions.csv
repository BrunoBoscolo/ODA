"Function Name","Header","Explanation"
"adaptive_mutation","adaptive_mutation(NeuralNetwork * network,float initial_mutation_rate,float mutation_chance,double fitness_std_dev)","Adaptive mutation"
"add_bias","add_bias(Matrix * m,const Matrix * bias)","Adds a bias vector to each row of a matrix"
"arithmetic_crossover","arithmetic_crossover(const NeuralNetwork * parent1,const NeuralNetwork * parent2)","Performs arithmetic crossover between two parent networks."
"backpropagate","backpropagate(NeuralNetwork * net,const Dataset * train_dataset,const GannBackpropParams * params,const Dataset * validation_dataset)","Main function to train the network using backpropagation"
"calculate_fitness","calculate_fitness(NeuralNetwork * network,const Dataset * dataset,int num_samples)","Fitness function used by the training loop"
"calculate_mse","calculate_mse(const NeuralNetwork * net,const Dataset * dataset)","--- Utility function to calculate Mean Squared Error ---"
"compare_fitness","compare_fitness(const void * a,const void * b)","Comparison function for qsort to sort networks by fitness in descending order"
"compare_fitness_desc","compare_fitness_desc(const void * a,const void * b)","--- Helper functions (private to this file) --- qsort comparison function for sorting networks by fitness in descending order"
"create_dummy_dataset","create_dummy_dataset(int num_items)","Creates a dummy dataset with random values"
"create_dummy_dataset_with_label","create_dummy_dataset_with_label(int num_items,int label)","Creates a dummy dataset with a specific label for all items"
"create_matrix","create_matrix(int rows,int cols)","--- Matrix Operations Implementation --- Creates and allocates memory for a new matrix"
"crossover","crossover(const NeuralNetwork * parent1,const NeuralNetwork * parent2,CrossoverType crossover_type)",""
"dot_product","dot_product(const Matrix * m1,const Matrix * m2)","Computes the dot product of two matrices"
"evo_create_initial_population","evo_create_initial_population(int population_size,int num_layers,const int * architecture,ActivationType activation_hidden,ActivationType activation_output)","--- Evolution Functions Implementation --- Creates an initial population of neural networks"
"evo_reproduce","evo_reproduce(const NetworkFitness * fittest_networks,int num_fittest,int new_population_size,CrossoverType crossover_type,int tournament_size)","Creates a new generation using crossover"
"free_dataset","free_dataset(Dataset * dataset)","Frees the memory allocated for a dataset"
"free_matrix","free_matrix(Matrix * m)","Frees the memory of a matrix"
"gann_create_default_params","gann_create_default_params(void)",""
"gann_error_to_string","gann_error_to_string(GannError error_code)",""
"gann_evaluate","gann_evaluate(const NeuralNetwork * net,const Dataset * dataset)",""
"gann_evolve","gann_evolve(const GannEvolveParams * params,const Dataset * train_dataset,const Dataset * validation_dataset)",""
"gann_get_last_error","gann_get_last_error(void)","--- Public API Functions ---"
"gann_predict","gann_predict(const NeuralNetwork * net,const double * input_data)",""
"gann_seed_rng","gann_seed_rng(unsigned int seed)","--- High-Level API Implementation ---"
"gann_set_error","gann_set_error(GannError error_code)","--- Internal Functions ---"
"gann_train","gann_train(const GannTrainParams * params,const Dataset * train_dataset,const Dataset * validation_dataset)",""
"gann_train_with_backprop","gann_train_with_backprop(const GannBackpropParams * params,const Dataset * train_dataset,const Dataset * validation_dataset)",""
"gaussian_mutation","gaussian_mutation(NeuralNetwork * network,float mutation_chance,double std_dev)","Gaussian mutation"
"get_predicted_class","get_predicted_class(const Matrix * output)","Helper to get the index of the max value in a matrix row (the prediction)"
"get_true_class","get_true_class(const double * label_row,int num_classes)","Helper to get the true class from a one-hot encoded label vector"
"leaky_relu","leaky_relu(double x)",""
"leaky_relu_derivative","leaky_relu_derivative(double x)",""
"load_mnist_dataset","load_mnist_dataset(const char * image_path,const char * label_path)","Loads the MNIST dataset from the specified files"
"matrix_add","matrix_add(const Matrix * m1,const Matrix * m2)","Adds two matrices"
"matrix_copy","matrix_copy(const Matrix * m)","Creates a deep copy of a matrix"
"matrix_copy_data","matrix_copy_data(Matrix * dest,const Matrix * src)",""
"matrix_elementwise_multiply","matrix_elementwise_multiply(const Matrix * m1,const Matrix * m2)","Performs element-wise multiplication (Hadamard product) of two matrices"
"matrix_from_array","matrix_from_array(const double * array,int rows,int cols)","Creates a matrix from a 1D array"
"matrix_get_row","matrix_get_row(const Matrix * m,int row)","Extracts a single row from a matrix"
"matrix_scale","matrix_scale(const Matrix * m,double scalar)","Scales a matrix by a scalar value"
"matrix_subtract","matrix_subtract(const Matrix * m1,const Matrix * m2)","Subtracts the second matrix from the first matrix"
"matrix_transpose","matrix_transpose(const Matrix * m)","Creates a new matrix that is the transpose of the input matrix"
"mutate_network","mutate_network(NeuralNetwork * network,float mutation_rate,float mutation_chance,MutationType mutation_type,double mutation_std_dev,int current_gen,int max_gens,double fitness_std_dev)",""
"nn_apply_activation","nn_apply_activation(Matrix * m,ActivationType activation_type)","--- Public API Functions ---"
"nn_apply_activation_derivative","nn_apply_activation_derivative(Matrix * m,ActivationType activation_type)",""
"nn_clone","nn_clone(const NeuralNetwork * src_net)",""
"nn_create","nn_create(int num_layers,const int * architecture,ActivationType activation_hidden,ActivationType activation_output)",""
"nn_forward_pass","nn_forward_pass(const NeuralNetwork * net,const Matrix * input)",""
"nn_free","nn_free(NeuralNetwork * net)",""
"nn_init","nn_init(NeuralNetwork * net)",""
"nn_init_optimizer_state","nn_init_optimizer_state(NeuralNetwork * net)",""
"nn_load","nn_load(const char * filepath)",""
"nn_save","nn_save(const NeuralNetwork * net,const char * filepath)",""
"non_uniform_mutation","non_uniform_mutation(NeuralNetwork * network,float mutation_rate,float mutation_chance,int current_gen,int max_gens)","Non-uniform mutation"
"print_matrix","print_matrix(const Matrix * m)","Prints the matrix data (for debugging)"
"randn","randn(double mu,double sigma)","Helper function for generating a random number from a Gaussian distribution"
"relu","relu(double x)",""
"relu_derivative","relu_derivative(double x)",""
"select_fittest","select_fittest(NetworkFitness * population_with_fitness,int population_size,int * num_fittest,SelectionType selection_type,int tournament_size)","Wrapper function to select fittest based on strategy"
"select_fittest_elitism","select_fittest_elitism(NetworkFitness * population_with_fitness,int population_size,int * num_fittest)","Selects the top-performing networks (elitism)"
"select_fittest_rank","select_fittest_rank(NetworkFitness * population_with_fitness,int population_size,int * num_fittest)","Selects networks using rank selection"
"select_fittest_roulette_wheel","select_fittest_roulette_wheel(NetworkFitness * population_with_fitness,int population_size,int * num_fittest)","Selects networks using roulette wheel selection"
"select_fittest_tournament","select_fittest_tournament(NetworkFitness * population_with_fitness,int population_size,int * num_fittest,int tournament_size)","Selects networks using a tournament"
"select_parent_tournament","select_parent_tournament(const NetworkFitness * candidates,int num_candidates,int tournament_size)","Helper function to select a parent using tournament selection"
"sigmoid","sigmoid(double x)","--- Private Activation Functions ---"
"sigmoid_derivative","sigmoid_derivative(double x)",""
"single_point_crossover","single_point_crossover(const NeuralNetwork * parent1,const NeuralNetwork * parent2)","Performs single-point crossover between two parent networks."
"split_dataset","split_dataset(const Dataset * original,int split_size,Dataset * out_dataset_1,Dataset * out_dataset_2)",""
"swap_endian","swap_endian(int val)","Helper function to swap endianness (from big-endian to little-endian)"
"two_point_crossover","two_point_crossover(const NeuralNetwork * parent1,const NeuralNetwork * parent2)","Performs two-point crossover between two parent networks."
"uniform_crossover","uniform_crossover(const NeuralNetwork * parent1,const NeuralNetwork * parent2)","Performs uniform crossover between two parent networks. For each weight and bias, the child's value is randomly taken from one of the two parents."
"uniform_mutation","uniform_mutation(NeuralNetwork * network,float mutation_rate,float mutation_chance)","Simple uniform mutation"
"update_weights_adam","update_weights_adam(NeuralNetwork * net,Matrix ** weight_gradients,Matrix ** bias_gradients,const GannBackpropParams * params,int batch_size,int t)",""
"update_weights_rmsprop","update_weights_rmsprop(NeuralNetwork * net,Matrix ** weight_gradients,Matrix ** bias_gradients,const GannBackpropParams * params,int batch_size)",""
"update_weights_sgd","update_weights_sgd(NeuralNetwork * net,Matrix ** weight_gradients,Matrix ** bias_gradients,const GannBackpropParams * params,int batch_size)","--- Optimizer-specific Weight Update Functions ---"
